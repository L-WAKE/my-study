<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('成功回调');
                // reject('失败的回调')
            }, 1000);
        }).then(
            (value) => {
                console.log('then', value);
            }
        ).catch(
            (reason) => {
                console.log('catch', reason);
            }
        )

        const p1 = new Promise((resolve, reject) => {
            setTimeout(() => { resolve('p1') }, 500)
        })
        const p2 = new Promise((resolve, reject) => {
            setTimeout(() => { resolve('p2') }, 400)
        })
        const p3 = new Promise((resolve, reject) => {
            setTimeout(() => { resolve('p3') }, 600)
        })
        // const p2 = Promise.resolve('p2');
        // const p3 = Promise.resolve('p3');

        /*  Promise.all 
            1.只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled
            此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数
            2.只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected
            此时第一个被reject的实例的返回值，会传递给p的回调函数
        */
        Promise.all([p1, p2, p3]).then(res => console.log('allThen', res)).catch(err => console.log('allError:', err))

        // Promise.race看谁先完成,无论失败或成功 会返回第一个成功的或第一个失败
        Promise.race([p1, p2, p3]).then(res => console.log('raceThen', res)).catch(err => console.log('raceError:', err))
    </script>
</body>

</html>